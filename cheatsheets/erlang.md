<!-- Фред Хеберт Изучай Erlang во имя добра! -->

Когда вы начинаете работать с новым языком програм м ирования, поначалу ка­жется, что всё, что вы делаете, — это изучаете новый язык. Но если посмотреть глубже? вы занимаетесь кое-чем более основательным — вы изучаете новый способ мышления. Именно этот новый способ мышления и является восхитительным, а не те незначительные подробности пунктуации в языке или как он выглядит в сравнении с вашим любимым языком.

# **Erlang**

Erlang — функциональный язык программирования. 

Когда функции всегда возвращают одинаковый результат для одних и тех же входных значений, это называется ссылочной прозрачностью ( referential transparency).


Erlang использует так называемую модель акторов, где каждый актор — это отдельный процесс внутри виртуальной машины. Простыми словами, если бы вы были актором в мире Erlang, вы были бы одиноким человеком, сидящим в тёмной комнате без окон и ожидающим сообщение из почтового ящика. Как только вы получили сообщение, вы реагируете на него каким-то особым способом: вы платите по счетам, если пришли счета, вы отвечаете на пожелания ко дню рождения письмами благодарности и игнорируете письма, содержание которых вам непонятно.
Модель акторов Erlang можно представить себе как мир, в котором все сидят одни в своих комнатах и могут делать всего несколько различных задач. Все общаются со всеми строго только посредством написания писем, и никак иначе. В то время как это может показаться очень скучной жизнью (и веком расцвета почтовых услуг), это означает, что вы можете попросить множество людей исполнить определённые задачи для вас, и никто из них никогда не ошибётся и не повлияет на работу других. Они даже могут не знать о существовании других людей, кроме вас (и это замечательно).

На практике Erlang заставляет вас писать акторов (процессы), которе не делятся информацией с другими частями кода никак иначе, кроме как передачей сообщений друг другу. Все коммуникации являются явными, безопасными, их можно перехватить и отследить в целях отладки.
Erlang — это не просто язык, но также и среда разработки в целом. Код компилиру­ется в байт-код и работает внутри виртуальной машины. Таким образом, Erlang, так же как Java и как дети-непоседы с шилом в попе, будет бегать где угодно.

Виртуальная машина и библиотеки также позволяют вам обновлять ваш код прямо во время работы системы без остановки любой программы, распространять ваш код с лёгкостью на множество компьютеров и управлять ошибками и сбоями в простой, по очень мощной манере.

Терм (term) — любое значение в языке Erlang.


ПРИМЕЧАНИЕ. Встроенные функции (BIFs) — это функции, которые нельзя было написать на чистом Erlang, и таким образом они написаны на языке С (или на Prolog в 1980-х годах). Некоторые BIF достаточно просты, чтобы их можно было написать и на Erlang, но они так часто используются в любом коде, что их всё равно переписали на С из соображений скорости.

## **Числа**
Erlang всё равно, вводите ли выдействительные или целые числа: оба типа чисел поддерживаются в арифметике (integer, float)

Можно использовать несколько операторов в одном вы ражении, математические операции подчиняются привычным правилам приоритета вычислений.

- div — Поделить целое число нацело (Деление — division)
- rem — Для вы числения остатка от целочисленного деления (Остаток — remainder)

Если вы хотите выразить целые числа в системе исчисления с другим основанием, кроме 10, просто введите число в виде Основание#Число (разрешённый диапазон для Основания — от 2 до З6 *(10 цифр и 26 букв
латинского алфавита)*)


## **Неизменные переменные**

**Переменные не могут быть изменяемыми в функциональном программировании.**

В Erlang имена переменных начинаются с заглавной буквы.

*Переменные также могут начинаться и с символа подчёрки­вания (_), но существует соглашение об использовании таких переменных только для значений, которые вам не интересны.*

## **Атомы**

Атомы являются литералами, константами, значением которых является их
имя.

Атом cat означает только слово «cat» (кот), и ничего более. С ним нельзя играть. Его нельзя менять. Его нельзя разделить на части. Это просто кот. Прими это как есть.

Атом должен быть заключён в одиночные кавычки (’), если он не начинается со строчной буквы или содержит любые другие символы, кроме букв, цифр, подчёрки­ваний (_) и @.



    Атомы очень удобны и являются прекрасным способом для посылки сообщ ений или представ­ления в программе констант. Однако есть и подводны е камни, если использовать атомы для слишком многих вещей. Атом сылается на специальную «таблицу атомов» в памяти, которая занимает не менее 4 байт на атом в 32-битных системах и не менее 8 байт в 64-битных системах (плюс длина имени атома). Атомы в этой таблице никогда не освобождаются, и разные имена атомов будут накапливаться в памяти до тех пор, пока система не рухнет, либо потому, что закончилась память, либо потому, что было достигнуто ограничени е длины таблицы атом ов (поумолчанию 1 048 577).

    Это означает, что не следует генерировать атомы динамически. Если ваша система должна быть надёжной, а ввод пользователей позволяет им обрушить ваш у систему, создавая атомы, то у вашей системы имеются серьёзные проблемы. Атомы следует рассматривать как инструменты для разработчика, потому что, откровенно говоря, они ими и являются. Ещё раз: можно абсолютно безопасно использовать атомы в вашем повседневном коде так долго, пока вы набираете их вручную сами. Динамическая генерация новых атомов — это рискованная затея.

*Некоторые атомы являются зарезервированными словами языка, и их нельзя использовать (вернее, можно, но придётся заключить в'одиночные кавычки’). Вот полный список: after, and, andalso, band, begin, bnot, bor, bsl, bsr, bxor, case, catch, cond, div, end, fun, if, let, not, of, or, orelse , query, receive, rem, try, when и xor.*

## **Булева алгебра и сравнение**

and, or, xor, not

    Булевы операторы and и or всегда вычисляют аргументы слева и справа от оператора. Если вам нужны более быстрые операторы (которые вычисляют правый аргумент,только если он нужен для завершения вычисления), используйте andalso и оrelse.

### Сравнение
|   Оператор   |                Описание           |
| ------------ | --------------------------------- |
|     =:=      |Равенство (с учетом типа)          |
|     =/=      |Неравенство                        |
|     /=       |Точное сравнение, включая тип числа|
|     ==       |Сравнение только значения          |
|      <       |Меньше, чем                        |
|      >       |Больше, чем                        |
|     >=       |Больше или равно                   |
|     =<       |Меньше или равно                   |


    14> 0 == false.
    false
    15> 1 < false.
    true

    Если вы пришли в Erlang из процедурных или объектно-ориентированных языков, то есть вероятность, что вы сейчас удивлены. Строка 14 должна была быть равна true, и строка 15 равна false! В конце концов, в нормальных языках false означает 0, и true — это всё остальное! Только не в Erlang. 
    В Erlang нет понятия логических значений true и false. Значения true и false — это атомы, но они достаточно хорошо встроены в язык, так что у вас не должно возникнуть проблем, пока вы не начнёте ожидать, что false и true должны иметь какие-то другие тайные значения.

ПРИМЕЧАНИЕ. Правильный порядок любых элементов в сравнении будет таким:
числа < атомы < ссылочные значения < функции < порты < идентификаторы процессов < кортежи < списки < двоичные данные

## **Кортежи**

Кортеж — это способ организовать ваши данные и сгруппировать множество значений,когда вы точно знаете их количество. 

В Erlang кортеж пишется в виде {Злемент1, Элемент2, ... ,ЭлементN}. 

---

Кортеж, который содержит атом и один дополнительный элемент, называется кортеж с тегом. Любой элемент кортежа может быть любым значением и даже другим кортежем. ({celsius, 23.213})

## **Списки**

Списки — это рабочая лошадка многих функциональных языков. Они используются для
решения множества проблем и, несомненно, являются самой используемой структурой
данных в Erlang. Списки могут содержать что угодно — числа, атомы, кортежи, другие
списки — ваши самые смелые фантазии в виде одной структуры. Вы можете смешивать разные типы данных в одном списке.

Обычный способ записи списка — это [Элемент1, Элемент2, ..., ЭлементN]


|   Оператор   |                Описание           |
| ------------ | --------------------------------- |
|     ++       |Склеивание двух списков            |
|     --       |Удаление элементов из списка       |

Оба оператора (и ++, и --) имеют правую ассоциативность. Это означает, что несколько подряд идущих операций -- или ++ будут выполнены справа налево.

---

Первый элемент в списке называется головой (списка), и остаток после головы — хвостом. 

|   Функция    |                Описание           |
| ------------ | --------------------------------- |
|   hd(List)   |Получение головы списка            |
|   tl(List)   |Получение хвоста списка            |

Получение головы списка или присоединение к списку новой головы — быстрая и эффективная операция. Практически все программы, которые работают со списками,
стараются работать по возможности с головой списка. И это используется так часто, что появился более простой способ отделить голову от списка с помощью сопоставления с образцом: [Голова|Хвост].

Оператор | , который мы здесь использовали, называется в других функциональных языках cons (constructor). (В Erlang нет ключевого слова или функции cons.) 

ПРИМЕЧАНИЕ.
Использование формы записи [1 | 2] конструирует структуру, которая назы­ вается нерегулярный список (improper list). Нерегулярные списки сработают в сопоставлении образцов в такой форме [Head |  ail], но не будут работать со стандартными функциями Erlang (даже с функцией length()). Это происходит потому, что Erlang ожидает правильных списков. Правильные списки имеют пустой список в качестве хвоста последней ячейки. При объявлении элемента списка, например [2], автоматически формируется правильный список. И [1 | [2]] тоже сработает! Нерегулярные списки хоть и синтаксически верны, но применяются довольно редко, в самодельных структурах данных.

## **Генераторы списков**

Генераторы списков (list comprehensions) позволяют строить и изменять существующие списки. Также они делают код программ короче и легче для понимания в сравнении с другими способами работы со списками. Они поначалу могут показаться трудными для понимания, но они стоят усилий. Они делают код чище и короче.

Генераторы списков основаны на идее записи множеств, если вы когда-либо изучали теорию множеств в курсе высшей математики, вы, вероятно, знакомы с такой записью. Запись множеств говорит вам, как построить множество, указывая, каким условиям должны соответствовать вы бранные элементы. 

Рецепт для генераторов списков в Erlang выглядит так:
[Выражение || Образец <- Список, Условие1, Условие2, ..., УсловиеN]
*Часть Образец <- Список называется выражением-генератором.*

    [X || X <- [1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10], X rem 2 =:= 0]. ----> [2 ,4 ,6 ,8, 10]

Так же можно иметь несколько выражений-генераторов:
[Выражение || Генератор1, Генератор2, ..., ГенераторN, Условие1, Условие2, ... УсловиеN]
    
    [X + Y || X <- [1,2], Y <- [2,3]]. ----> [3, 4, 4, 5]

Генераторы списков полезны, когда мы хотим применить функцию к каждому элементу списка, с учётом заданных нами ограничений.

## **Работа с двоичными данными**

TODO

